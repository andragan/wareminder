# Data Model: WhatsApp Follow-Up Reminder Extension (MVP)

**Branch**: `001-followup-reminders` | **Date**: 2026-02-15 | **Plan**: [plan.md](plan.md)

---

## Storage Layer

**Engine**: `chrome.storage.local`  
**Quota**: 10MB (default without `unlimitedStorage` permission)  
**Access Pattern**: Single-writer (service worker); all contexts read via `onChanged` listener  
**Schema Version**: 1

---

## Entities

### 1. Reminder

The core entity. Represents a user's intention to follow up with a specific WhatsApp contact or group at a scheduled time.

| Field | Type | Required | Description |
|---|---|---|---|
| `id` | `string` (UUID v4) | Yes | Unique identifier. Generated by service worker on creation. |
| `chatId` | `string` | Yes | WhatsApp JID format: `<phone>@c.us` (individual) or `<id>@g.us` (group). Used for navigation via `https://web.whatsapp.com/send?phone=<phone>`. |
| `chatName` | `string` | Yes | Display name of the contact or group. Extracted from WhatsApp Web DOM at creation time. Used in notifications and dashboard display. |
| `scheduledTime` | `number` (epoch ms) | Yes | When the reminder should fire. Must be in the future at creation time. Stored as `Date.now()`-style milliseconds since Unix epoch. |
| `createdAt` | `number` (epoch ms) | Yes | Timestamp of reminder creation. Auto-set by service worker. |
| `status` | `string` (enum) | Yes | Current state: `"pending"` or `"completed"`. See State Transitions below. |
| `completedAt` | `number \| null` (epoch ms) | No | Timestamp when the user marked the reminder as completed. `null` while status is `"pending"`. Set automatically when status transitions to `"completed"`. |

**Example**:
```json
{
  "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "chatId": "5511999999999@c.us",
  "chatName": "John Doe",
  "scheduledTime": 1739836800000,
  "createdAt": 1739750400000,
  "status": "pending",
  "completedAt": null
}
```

#### Validation Rules

| Rule | Field(s) | Description | Spec Reference |
|---|---|---|---|
| Future time | `scheduledTime` | Must be strictly greater than `Date.now()` at creation. | FR-003 |
| Required fields | `chatId`, `chatName`, `scheduledTime` | All must be non-empty/non-null. | FR-004 |
| Valid JID format | `chatId` | Must match pattern `\d+@(c\.us\|g\.us)`. | Assumption (chat identifier) |
| Non-empty name | `chatName` | Must be a non-empty trimmed string. | FR-004 |
| Status enum | `status` | Must be `"pending"` or `"completed"`. | FR-004 |
| Plan limit | (aggregate) | Total reminders where `status === "pending"` must not exceed plan limit (5 for free). | FR-009 |

#### State Transitions

```
                    User clicks              30 days after
   [CREATE] ──→  "Mark Complete"  ──→      completedAt
  ┌────────┐    ┌──────────────┐    ┌──────────────────┐
  │ pending │───│  completed   │───│  AUTO-DELETED     │
  └────────┘    └──────────────┘    └──────────────────┘
       │                                     ▲
       │         User clicks "Delete"        │
       └──────────── DELETED ────────────────┘
                (immediate removal)
```

**Transitions**:
- `pending` → `completed`: User action ("Mark Complete" in dashboard). Sets `completedAt = Date.now()`. Decrements pending count. Clears associated alarm.
- `pending` → **DELETED**: User action ("Delete" in dashboard, with confirmation). Removes from storage entirely. Clears associated alarm.
- `completed` → **AUTO-DELETED**: Background process. Removes reminders where `completedAt + 30 days < Date.now()`. Runs on service worker startup. (FR-015)
- `pending` remains `pending` when overdue: If `scheduledTime < Date.now()` and status is still `"pending"`, the reminder is displayed as "overdue" in the dashboard with visual distinction. Status does NOT auto-change. (FR-016)

#### Derived Properties (computed, not stored)

| Property | Derivation | Usage |
|---|---|---|
| `isOverdue` | `status === "pending" && scheduledTime < Date.now()` | Visual distinction in popup dashboard |
| `pendingCount` | `reminders.filter(r => r.status === "pending").length` | Badge count (FR-008) |
| `navigationUrl` | `https://web.whatsapp.com/send?phone=${chatId.replace("@c.us", "")}` | Notification click-through (FR-006, FR-014) |

---

### 2. UserPlan

Tracks the user's subscription tier. For MVP, this is a simple object stored alongside reminders.

| Field | Type | Required | Description |
|---|---|---|---|
| `planType` | `string` (enum) | Yes | `"free"` or `"paid"`. Defaults to `"free"` on first install. |
| `activeReminderLimit` | `number` | Yes | Maximum pending reminders allowed. `5` for free, `Infinity` (stored as `-1`) for paid. |

**Example**:
```json
{
  "planType": "free",
  "activeReminderLimit": 5
}
```

**Note**: For MVP, `planType` is always `"free"`. The paid upgrade path is a UI-only stub (shows upgrade message per FR-009). Actual payment integration is post-MVP.

---

## Storage Schema

All data is stored in `chrome.storage.local` under two top-level keys:

```json
{
  "reminders": [
    {
      "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
      "chatId": "5511999999999@c.us",
      "chatName": "John Doe",
      "scheduledTime": 1739836800000,
      "createdAt": 1739750400000,
      "status": "pending",
      "completedAt": null
    }
  ],
  "userPlan": {
    "planType": "free",
    "activeReminderLimit": 5
  }
}
```

### Storage Budget

| Metric | Value | Calculation |
|---|---|---|
| Avg. reminder size | ~250 bytes | JSON-serialized, typical field lengths |
| 10,000 reminders | ~2.5 MB | 10,000 × 250 bytes |
| Storage quota | 10 MB | `chrome.storage.local` default |
| Headroom at 10K | ~75% free | 2.5 / 10 MB |
| 90% warning threshold | ~36,000 reminders | Practical limit before warning (edge case) |

### Indexes (Logical)

No physical indexes exist in `chrome.storage.local`. The following access patterns are served by in-memory array operations:

| Access Pattern | Operation | Frequency |
|---|---|---|
| Get all reminders | Full array read | Popup open, badge update |
| Get pending reminders | `filter(r => r.status === "pending")` | Badge count, plan limit check |
| Get overdue reminders | `filter(r => r.status === "pending" && r.scheduledTime < now)` | Dashboard display, startup check |
| Find by ID | `find(r => r.id === id)` | Notification click, complete/delete |
| Sort by due date | `sort((a, b) => a.scheduledTime - b.scheduledTime)` | Dashboard display (FR-007) |
| Expired completed | `filter(r => r.status === "completed" && r.completedAt + 30d < now)` | Auto-cleanup (FR-015) |

---

## Relationships

```
┌──────────────┐         ┌──────────────┐
│   Reminder   │ N ── 1  │ Chat (external) │
│              │         │                 │
│ chatId ──────┼────────►│ JID             │
│ chatName     │         │ (WhatsApp Web)  │
└──────────────┘         └─────────────────┘
       │
       │ N ── 1
       ▼
┌──────────────┐
│   UserPlan   │
│              │
│ planType     │
│ activeLimit  │
└──────────────┘
```

- **Reminder → Chat**: Many-to-one. Multiple reminders can reference the same chat. The chat is an external entity (WhatsApp Web DOM) — only `chatId` and `chatName` are stored as denormalized fields on the Reminder.
- **Reminder → UserPlan**: Many-to-one (implicit). The plan constrains how many pending reminders can exist. No foreign key — the constraint is enforced at the service layer.
- **Reminder → Alarm**: One-to-one (external). Each pending reminder with a future `scheduledTime` has a corresponding `chrome.alarms` alarm named `reminder-<id>`. The alarm is the scheduling mechanism, not persistent data — alarms are reconciled from storage on startup.

---

## Migration Strategy

**Schema Version 1** (MVP): No migrations needed — greenfield.

For future schema changes:
1. Add a `schemaVersion` key to storage (default: `1`)
2. On service worker startup, check `schemaVersion` and run any pending migrations
3. Migrations are sequential: v1→v2, v2→v3, etc.
4. Each migration is an idempotent function that transforms the stored data

```javascript
// Future pattern (not implemented in MVP)
const CURRENT_SCHEMA = 1;
const { schemaVersion = 1 } = await chrome.storage.local.get('schemaVersion');
if (schemaVersion < CURRENT_SCHEMA) {
  await runMigrations(schemaVersion, CURRENT_SCHEMA);
}
```
